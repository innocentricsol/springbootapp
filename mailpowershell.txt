
In recent years, container-based virtualization technology for edge and cloud computing has advanced dramatically. Virtualization solutions based on Docker Containers provide a more lightweight and efficient virtual environment for Edge and cloud-based applications. Because their use is growing on its own and is still in its early phases, these technologies will face a slew of security issues. Vulnerabilities and malware in Docker container images are two serious security concerns. The risk of privilege escalation is increased because Docker containers share the Linux kernel. As organizations increasingly rely on containerization for application deployment, the need for a secure, decentralized, and privacy-preserving storage solution for Docker images becomes paramount. 


This study presents a distributed system framework called Safe Docker Image Sharing with Homomorphic Encryption and Blockchain (SeDIS-HEB). Through homomorphic encryption, authentication, and access management, SeDIS-HEB provides secure docker image sharing. 

The SeDIS-HEB framework prioritizes the following three major functions: (1) secure docker image upload, (2) secure docker image sharing, and (3) secure docker image download. The proposed framework was evaluated using the InterPlanetary File System (IPFS).

 Secure Docker images were uploaded using IPFS, preventing unauthorized users from accessing the data contained within the secure Docker images. The SeDIS-HEB results were transparent and ensured the quality of blockchain data access control authentication, docker image metadata denial-of-service protection, and docker image availability.



# This PowerShell script sends an email

# Define email parameters
$SMTPServer = "smtp.example.com"
$SMTPPort = 587
$SMTPUsername = "your_username@example.com"
$SMTPPassword = "your_password"
$SenderEmail = "your_username@example.com"
$RecipientEmail = "recipient@example.com"
$Subject = "Test Email"
$Body = "This is a test email sent from PowerShell."

# Create email credentials
$SMTPCredentials = New-Object System.Management.Automation.PSCredential ($SMTPUsername, (ConvertTo-SecureString $SMTPPassword -AsPlainText -Force))

# Send the email
Send-MailMessage -SmtpServer $SMTPServer -Port $SMTPPort -From $SenderEmail -To $RecipientEmail -Subject $Subject -Body $Body -Credential $SMTPCredentials -UseSsl




$From = "mother-of-dragons@houseoftargaryen.net"
$To = "jon-snow@winterfell.com", "jorah-mormont@night.watch"
$Cc = "tyrion-lannister@westerlands.com"
$Attachment = "C:\Temp\Drogon.jpg"
$Subject = "Photos of Drogon"
$Body = "<h2>Guys, look at these pics of Drogon!</h2><br><br>"
$Body += "He is so cute!"
$SMTPServer = "smtp.mailtrap.io"
$SMTPPort = "587"
Send-MailMessage -From $From -to $To -Cc $Cc -Subject $Subject -Body $Body -BodyAsHtml -SmtpServer $SMTPServer -Port $SMTPPort -UseSsl -Credential (Get-Credential) -Attachments $Attachment


Send-MailMessage -To '<recipient’s email address>' -From '<sender’s email address>' -Subject 'Your message subject' -Body 'Some important plain text!' -Credential (Get-Credential) -SmtpServer '<smtp server>' -Port 587



# This is a PowerShell script file with a CD command

# Change the current working directory to C:\ExampleDirectory
cd C:\Windows\System32\inetsrv

# You can also use the Set-Location cmdlet to achieve the same result
# Set-Location C:\Windows\System32\inetsrv

# Now, let's display the current working directory to verify the change
# Write-Host "Current Directory: $(Get-Location)"

$AppPool_Name = "testet"
$AppPool_Status = .\appcmd list apppools $AppPool_Name /text:state

if ($AppPool_Status -eq "Stopped") {
    .\appcmd start apppool /apppool.name:$AppPool_Name
}
